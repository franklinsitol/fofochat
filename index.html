// Modifique a função acceptIncomingCall para incluir validações adicionais
async function acceptIncomingCall() {
    if (!state.incomingCallOffer || !state.incomingCallOffer.offer) {
        console.error('Oferta de chamada inválida ou ausente');
        return;
    }

    try {
        hideCallNotification();
        
        state.isCaller = false;
        const callerId = state.incomingCallOffer.from;
        const caller = state.contactsCache[callerId];
        
        // Configura a UI da chamada
        elements.displays.callerName.textContent = caller?.name || 'Desconhecido';
        elements.displays.callStatus.textContent = "Chamada em andamento";
        elements.displays.callContainer.style.display = 'flex';
        
        // Obtém stream local
        state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        elements.displays.localVideo.srcObject = state.localStream;
        
        // Configura a conexão WebRTC
        state.rtcConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        });
        
        // Adiciona tracks locais
        state.localStream.getTracks().forEach(track => {
            state.rtcConnection.addTrack(track, state.localStream);
        });
        
        // Configura handlers
        state.rtcConnection.onicecandidate = ({ candidate }) => {
            if (candidate) {
                gun.get('users').get(callerId).get('iceCandidates').put({
                    from: state.currentUser.id,
                    candidate: candidate
                });
            }
        };
        
        state.rtcConnection.ontrack = ({ streams: [stream] }) => {
            elements.displays.remoteVideo.srcObject = stream;
            state.remoteStream = stream;
        };

        // Validação adicional da oferta
        if (!state.incomingCallOffer.offer || !state.incomingCallOffer.offer.type || !state.incomingCallOffer.offer.sdp) {
            throw new Error('Oferta de chamada inválida');
        }

        // Configura a oferta remota
        const offer = new RTCSessionDescription({
            type: state.incomingCallOffer.offer.type,
            sdp: state.incomingCallOffer.offer.sdp
        });
        
        await state.rtcConnection.setRemoteDescription(offer);
        
        // Cria e envia a resposta
        const answer = await state.rtcConnection.createAnswer();
        await state.rtcConnection.setLocalDescription(answer);
        
        // Envia a resposta para o chamador
        gun.get('users').get(callerId).get('callAnswer').put({
            type: 'answer',
            answer: {
                type: answer.type,
                sdp: answer.sdp
            }
        });
        
        // Escuta por candidatos ICE
        gun.get('users').get(state.currentUser.id).get('iceCandidates').on(async (data) => {
            if (!data || !data.candidate || data.from !== callerId) return;
            try {
                await state.rtcConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            } catch (e) {
                console.error('Erro ao adicionar ICE candidate:', e);
            }
        });
        
    } catch (error) {
        console.error('Erro ao aceitar chamada:', error);
        endCall();
        alert('Erro ao aceitar chamada: ' + error.message);
    } finally {
        state.incomingCallOffer = null;
    }
}

// Modifique também a função startCall para garantir que a oferta seja válida
async function startCall() {
    if (!state.currentUser || !state.currentContact) return;
    
    try {
        // Configuração básica da chamada
        state.isCaller = true;
        elements.displays.callerName.textContent = state.currentContact.name;
        elements.displays.callStatus.textContent = "Chamando...";
        elements.displays.callContainer.style.display = 'flex';
        
        // Obter stream de mídia local
        state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        elements.displays.localVideo.srcObject = state.localStream;
        
        // Configuração simplificada do RTCPeerConnection
        state.rtcConnection = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        });
        
        // Adiciona os tracks locais à conexão
        state.localStream.getTracks().forEach(track => {
            state.rtcConnection.addTrack(track, state.localStream);
        });
        
        // Manipulador para candidatos ICE
        state.rtcConnection.onicecandidate = ({ candidate }) => {
            if (candidate) {
                // Envia candidatos ICE para o contato
                gun.get('users').get(state.currentContact.id).get('iceCandidates').put({
                    from: state.currentUser.id,
                    candidate: candidate
                });
            }
        };
        
        // Quando receber um stream remoto
        state.rtcConnection.ontrack = ({ streams: [stream] }) => {
            elements.displays.remoteVideo.srcObject = stream;
            state.remoteStream = stream;
            elements.displays.callStatus.textContent = "Chamada em andamento";
        };
        
        // Se for o chamador, cria uma oferta
        const offer = await state.rtcConnection.createOffer();
        await state.rtcConnection.setLocalDescription(offer);
        
        // Envia a oferta para o contato (garantindo a estrutura correta)
        gun.get('users').get(state.currentContact.id).get('callOffer').put({
            from: state.currentUser.id,
            offer: {
                type: offer.type,
                sdp: offer.sdp
            },
            timestamp: Date.now()
        });
        
        // Configura timeout para chamada não atendida
        state.callTimeout = setTimeout(() => {
            if (!state.remoteStream) {
                endCall();
                alert("Chamada não atendida");
            }
        }, 45000); // 45 segundos para atender
        
        // Escuta por respostas
        gun.get('users').get(state.currentUser.id).get('callAnswer').on(async (answer) => {
            if (!answer || !answer.answer) return;
            
            if (answer.type === 'answer') {
                clearTimeout(state.callTimeout);
                
                // Validação da resposta
                if (!answer.answer.type || !answer.answer.sdp) {
                    throw new Error('Resposta de chamada inválida');
                }
                
                await state.rtcConnection.setRemoteDescription(new RTCSessionDescription({
                    type: answer.answer.type,
                    sdp: answer.answer.sdp
                }));
                
                elements.displays.callStatus.textContent = "Chamada em andamento";
            } else if (answer.type === 'reject') {
                clearTimeout(state.callTimeout);
                endCall();
                alert(`${state.currentContact.name} recusou a chamada.`);
            }
        });
        
    } catch (error) {
        console.error('Erro ao iniciar chamada:', error);
        endCall();
        alert('Erro ao iniciar chamada: ' + error.message);
    }
}
