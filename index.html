<!DOCTYPE html>
<html lang="pt-BR">
<!-- [Cabeçalho e CSS permanecem exatamente iguais] -->
<script>
    // [Configuração inicial e estado permanecem iguais até a função generateQrCode]

    // Gera o QR Code do usuário (modificada)
    function generateQrCode() {
        if (!state.currentUser) return;
        
        const qrToken = Math.random().toString(36).slice(2, 12);
        const qrData = JSON.stringify({
            app: "BunnyChat",
            version: 1,
            userId: state.currentUser.id,
            token: qrToken,
            userName: state.currentUser.name
            // Removido o timestamp para o QR não expirar
        });
        
        // Atualiza o token no usuário
        gun.get('users').get(state.currentUser.id).put({
            ...state.currentUser,
            qrToken: qrToken
        });
        
        // Gera o QR Code
        QRCode.toCanvas(elements.displays.qrCode, qrData, {
            width: 200,
            margin: 2,
            color: {
                dark: '#5A2A3E',
                light: '#FFF2F5'
            }
        }, (error) => {
            if (error) {
                console.error('Erro ao gerar QR Code:', error);
            }
        });
        
        elements.inputs.userIdInput.value = state.currentUser.id;
    }

    // Função modificada para verificação do QR code
    function startQrScanner() {
        stopQrScanner();
        
        navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: state.currentCamera,
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        }).then(function(stream) {
            elements.displays.qrVideo.srcObject = stream;
            elements.displays.qrVideo.setAttribute('playsinline', true);
            elements.displays.qrVideo.play();
            
            elements.displays.qrVideo.onplaying = () => {
                elements.displays.scanOverlay.style.display = 'none';
            };
            
            const canvasElement = document.createElement('canvas');
            const canvas = canvasElement.getContext('2d', { willReadFrequently: true });
            let scanning = true;
            
            function scanFrame() {
                if (!scanning) return;
                
                try {
                    if (elements.displays.qrVideo.readyState === elements.displays.qrVideo.HAVE_ENOUGH_DATA) {
                        canvasElement.width = elements.displays.qrVideo.videoWidth;
                        canvasElement.height = elements.displays.qrVideo.videoHeight;
                        canvas.drawImage(elements.displays.qrVideo, 0, 0, canvasElement.width, canvasElement.height);
                        
                        const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: 'dontInvert'
                        });
                        
                        if (code) {
                            try {
                                const qrData = JSON.parse(code.data);
                                
                                if (qrData.app === "BunnyChat" && qrData.userId && qrData.token) {
                                    if (qrData.userId === state.currentUser.id) {
                                        alert('Você não pode adicionar a si mesmo!');
                                        return;
                                    }
                                    
                                    // Removida a verificação de expiração do QR code
                                    gun.get('users').get(qrData.userId).once((user) => {
                                        if (user && user.qrToken === qrData.token) {
                                            stopQrScanner();
                                            addContact(qrData.userId, user.name || qrData.userName || 'Novo Contato');
                                        } else {
                                            alert('QR Code inválido');
                                        }
                                    });
                                }
                            } catch (e) {
                                console.error('Erro ao ler QR Code:', e);
                            }
                        }
                    }
                    
                    requestAnimationFrame(scanFrame);
                } catch (e) {
                    console.error('Erro no scanner:', e);
                    scanning = false;
                    stopQrScanner();
                }
            }
            
            scanFrame();
        }).catch(function(err) {
            console.error('Erro ao acessar a câmera:', err);
            elements.displays.scanOverlay.innerHTML = `
                <div>
                    <i class="fas fa-camera-slash"></i>
                    <p>Não foi possível acessar a câmera</p>
                    <p>Verifique as permissões do navegador</p>
                    <button id="tryAgainBtn" class="btn btn-small" style="margin-top: 10px;">Tentar novamente</button>
                </div>
            `;
            
            document.getElementById('tryAgainBtn').addEventListener('click', startQrScanner);
        });
    }

    // Função modificada para enviar mensagens com expiração
    function sendMessage() {
        if (!state.currentUser || !state.currentContact) return;
        
        const messageText = elements.inputs.message.value.trim();
        if (!messageText) return;
        
        const messageId = Gun.text.random(16);
        const message = {
            id: messageId,
            sender: state.currentUser.id,
            receiver: state.currentContact.id,
            text: messageText,
            timestamp: Date.now(),
            expiresAt: Date.now() + 24 * 60 * 60 * 1000, // 24 horas a partir de agora
            read: false
        };
        
        // Salva a mensagem para o remetente no GunDB
        gun.get('users').get(state.currentUser.id).get('messages').get(messageId).put(message, ack => {
            if (!ack.err) {
                // Salva no cache local
                state.processedMessages.add(messageId);
                localStorage.setItem('bunnyChatMessages', JSON.stringify(Array.from(state.processedMessages)));
            }
        });
        
        // Salva a mensagem para o destinatário no GunDB
        gun.get('users').get(state.currentContact.id).get('messages').get(messageId).put(message);
        
        // Limpa o campo de mensagem
        elements.inputs.message.value = '';
        
        // Atualiza a tela de mensagens
        loadChatMessages(state.currentContact.id);
    }

    // Nova função para limpar mensagens expiradas
    function cleanupExpiredMessages() {
        if (!state.currentUser) return;
        
        const now = Date.now();
        
        gun.get('users').get(state.currentUser.id).get('messages').map().once((message, id) => {
            if (!message || !message.expiresAt) return;
            
            if (message.expiresAt < now) {
                // Remove mensagem expirada
                gun.get('users').get(state.currentUser.id).get('messages').get(id).put(null);
                
                // Remove do cache local se existir
                if (state.processedMessages.has(id)) {
                    state.processedMessages.delete(id);
                    localStorage.setItem('bunnyChatMessages', JSON.stringify(Array.from(state.processedMessages)));
                }
            }
        });
    }

    // Modificação na função de carregar mensagens para filtrar por expiração
    function loadChatMessages(contactId) {
        if (!state.currentUser) return;
        
        elements.displays.chatMessages.innerHTML = '';
        let hasMessages = false;
        const now = Date.now();
        
        // Verifica mensagens no cache local primeiro
        gun.get('users').get(state.currentUser.id).get('messages').map().once((message, id) => {
            if (!message || state.processedMessages.has(message.id)) return;
            
            // Verifica se a mensagem expirou
            if (message.expiresAt && message.expiresAt < now) {
                return;
            }
            
            state.processedMessages.add(message.id);
            localStorage.setItem('bunnyChatMessages', JSON.stringify(Array.from(state.processedMessages)));
            
            // Verifica se a mensagem é para/deste contato
            const isRelevant = (message.sender === contactId && message.receiver === state.currentUser.id) || 
                              (message.sender === state.currentUser.id && message.receiver === contactId);
            
            if (!isRelevant) return;
            
            hasMessages = true;
            const isSender = message.sender === state.currentUser.id;
            const senderName = isSender ? 'Você' : state.currentContact.name;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'message-item';
            messageElement.style.alignItems = isSender ? 'flex-end' : 'flex-start';
            messageElement.style.backgroundColor = isSender ? 'var(--secondary)' : 'white';
            messageElement.innerHTML = `
                <div class="message-header">
                    ${!isSender ? `<div class="avatar message-avatar">${state.currentContact.name.charAt(0).toUpperCase()}</div>` : ''}
                    <div class="message-sender">${senderName}</div>
                    <div class="message-time">${formatTime(message.timestamp)}</div>
                </div>
                <div class="message-content">
                    ${escapeHtml(message.text)}
                </div>
            `;
            
            elements.displays.chatMessages.appendChild(messageElement);
            
            // Rolagem automática para a última mensagem
            elements.displays.chatMessages.scrollTop = elements.displays.chatMessages.scrollHeight;
            
            // Marca a mensagem como lida se for do outro usuário
            if (!isSender && !message.read) {
                gun.get('users').get(state.currentUser.id).get('messages').get(id).put({
                    ...message,
                    read: true
                });
            }
        });
        
        if (!hasMessages) {
            elements.displays.chatMessages.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-comment-dots"></i>
                    <p>Nenhuma mensagem ainda</p>
                    <p>Envie uma mensagem para começar a conversa!</p>
                </div>
            `;
        }
    }

    // Adiciona limpeza periódica de mensagens expiradas
    function init() {
        setupEventListeners();
        checkForExistingUser();
        setupNetworkMonitoring();
        
        if (!isMobileDevice()) {
            elements.buttons.switchCamera.style.display = 'block';
        }
        
        // Sincronização periódica
        setInterval(syncContacts, 30000);
        
        // Limpeza de mensagens expiradas a cada hora
        setInterval(cleanupExpiredMessages, 60 * 60 * 1000);
        
        // Executa a limpeza imediatamente ao iniciar
        cleanupExpiredMessages();
    }

    // [Restante do código permanece inalterado]
</script>
</html>
