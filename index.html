<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BunnyChat - Mensagens e Chamadas</title>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #FF9BB3;
            --secondary: #FFD1DC;
            --dark: #5A2A3E;
            --light: #FFF2F5;
            --success: #4CAF50;
            --error: #F44336;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --border-radius: 15px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Comic Neue', sans-serif; }
        body { background-color: var(--light); color: var(--dark); line-height: 1.6; min-height: 100vh; }
        header { background-color: var(--primary); color: white; text-align: center; padding: 15px 0; box-shadow: var(--shadow); }
        header h1 { font-size: 2rem; font-weight: 700; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        .screen { display: none; animation: fadeIn 0.3s ease; }
        .screen.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 30px; }
        .btn { background-color: var(--primary); color: white; border: none; border-radius: var(--border-radius); padding: 15px; font-size: 1.1rem; cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden; box-shadow: var(--shadow); }
        .btn:hover { background-color: #ff85a2; transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }
        .feedback-message { padding: 10px; margin: 10px 0; border-radius: var(--border-radius); text-align: center; }
        .feedback-success { background-color: rgba(76, 175, 80, 0.2); color: var(--success); border: 1px solid var(--success); }
        .feedback-error { background-color: rgba(244, 67, 54, 0.2); color: var(--error); border: 1px solid var(--error); }
        input[type="text"] { width: 100%; padding: 12px; margin: 8px 0; border: 2px solid var(--primary); border-radius: var(--border-radius); font-size: 1rem; background-color: white; }
        input[type="text"]:focus { outline: none; border-color: var(--dark); }
        .avatar { width: 40px; height: 40px; border-radius: 50%; background-color: var(--primary); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; }
        .contact-item { display: flex; align-items: center; padding: 12px; background-color: white; border-radius: var(--border-radius); margin-bottom: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: var(--shadow); }
        .contact-item:hover { transform: translateY(-2px); box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1); }
        .delete-contact-btn, .call-contact-btn { background: none; border: none; cursor: pointer; font-size: 1rem; padding: 5px; margin-left: 10px; }
        .delete-contact-btn { color: var(--error); }
        .call-contact-btn { color: var(--success); }
        .user-info { background-color: white; padding: 15px; border-radius: var(--border-radius); margin-bottom: 20px; box-shadow: var(--shadow); }
        .qr-code-container { display: flex; justify-content: center; margin: 20px 0; }
        .qr-code { border: 10px solid white; border-radius: var(--border-radius); box-shadow: var(--shadow); }
        #chatScreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; background-color: var(--light); z-index: 1000; padding: 0; margin: 0; display: none; flex-direction: column; }
        #chatScreen.active { display: flex; }
        .chat-header { display: flex; align-items: center; padding: 15px; background-color: var(--primary); color: white; position: sticky; top: 0; z-index: 10; box-shadow: var(--shadow); }
        .chat-messages { padding: 15px; background-color: white; flex: 1; overflow-y: auto; padding-bottom: 80px; }
        .empty-state { text-align: center; padding: 40px 0; color: #888; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .message-item { margin-bottom: 15px; max-width: 80%; padding: 10px 15px; border-radius: var(--border-radius); }
        .message-header { display: flex; align-items: center; margin-bottom: 5px; }
        .message-avatar { width: 30px; height: 30px; font-size: 0.8rem; margin-right: 8px; }
        .message-time { font-size: 0.8rem; opacity: 0.7; }
        .call-button-container { margin-top: 10px; text-align: center; }
        .call-button { background-color: var(--primary); color: white; border: none; border-radius: var(--border-radius); padding: 8px 15px; cursor: pointer; display: inline-flex; align-items: center; gap: 5px; font-size: 0.9rem; }
        .message-input-container { position: fixed; bottom: 0; left: 0; right: 0; background-color: white; padding: 15px; box-shadow: var(--shadow); display: flex; align-items: center; gap: 10px; z-index: 1010; }
        .send-btn, .call-btn { background-color: var(--primary); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .floating-buttons { position: fixed; bottom: 20px; right: 20px; display: none; flex-direction: column; gap: 10px; z-index: 100; }
        .floating-buttons.visible { display: flex; }
        .floating-btn { width: 50px; height: 50px; border-radius: 50%; background-color: var(--primary); color: white; border: none; font-size: 1.2rem; cursor: pointer; box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        .call-container { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; }
        .call-container.active { display: flex; }
        .call-video-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; width: 100%; max-width: 800px; margin-bottom: 20px; }
        .call-video { background-color: black; border-radius: var(--border-radius); overflow: hidden; width: 100%; max-width: 400px; height: 300px; }
        .call-video.small { position: absolute; bottom: 100px; right: 20px; width: 120px; height: 90px; z-index: 10; }
        .call-buttons { display: flex; gap: 20px; position: fixed; bottom: 20px; left: 0; right: 0; justify-content: center; z-index: 20; }
        .call-button { width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer; border: none; box-shadow: var(--shadow); }
        .call-accept { background-color: var(--success); color: white; }
        .call-reject { background-color: var(--error); color: white; }
        .call-end { background-color: var(--error); color: white; }
        .call-mute { background-color: var(--dark); color: white; }
        .hidden { display: none !important; }
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .floating-buttons { bottom: 10px; right: 10px; }
            .floating-btn { width: 45px; height: 45px; font-size: 1rem; }
            .chat-messages { padding-bottom: 70px; }
            .message-input-container { padding: 10px; }
            .call-button { width: 50px; height: 50px; font-size: 1.2rem; }
            .call-video { max-width: 100%; height: 200px; }
            .call-video.small { width: 80px; height: 60px; bottom: 80px; }
        }
    </style>
</head>
<body>
    <header><h1>BunnyChat</h1></header>
    <div class="container">
        <div id="userSelectScreen" class="screen active">
            <div class="btn-group">
                <button id="newUserBtn" class="btn"><span class="btn-text">Novo Usuário</span></button>
                <button id="existingUserBtn" class="btn"><span class="btn-text">Usuário Existente</span></button>
            </div>
        </div>
        <div id="newUserScreen" class="screen">
            <div style="text-align: center; margin: 20px 0;"><h2>Criar Novo Usuário</h2></div>
            <div style="margin-bottom: 20px;">
                <label for="newUserName">Seu Nome:</label>
                <input type="text" id="newUserName" placeholder="Digite seu nome">
            </div>
            <button id="createUserBtn" class="btn" style="width: 100%;"><span class="btn-text">Criar Usuário</span></button>
            <div id="createUserFeedback" class="feedback-message hidden"></div>
            <button id="backToSelectFromNew" class="btn" style="margin-top: 10px; width: 100%;"><span class="btn-text">Voltar</span></button>
        </div>
        <div id="existingUserScreen" class="screen">
            <div style="text-align: center; margin: 20px 0;"><h2>Usar Usuário Existente</h2></div>
            <div style="margin-bottom: 20px;">
                <label for="existingUserId">ID do Usuário:</label>
                <input type="text" id="existingUserId" placeholder="Digite seu ID de usuário">
            </div>
            <button id="loadUserBtn" class="btn" style="width: 100%;"><span class="btn-text">Carregar Usuário</span></button>
            <div id="loadUserFeedback" class="feedback-message hidden"></div>
            <button id="backToSelectFromExisting" class="btn" style="margin-top: 10px; width: 100%;"><span class="btn-text">Voltar</span></button>
        </div>
        <div id="mainScreen" class="screen">
            <div id="contactsSection" style="margin-top: 20px; display: block;">
                <h3>Seus Contatos</h3>
                <div id="contactsList" style="margin-top: 10px;"></div>
            </div>
            <div id="qrSection" class="hidden" style="margin-top: 20px;">
                <div class="user-info">
                    <div class="user-info-item"><span class="user-info-label">Seu Nome:</span><span id="userNameDisplay"></span></div>
                    <div class="user-info-item"><span class="user-info-label">Seu ID:</span><span id="userIdDisplayText"></span></div>
                </div>
                <h3 style="text-align: center;">Meu QR Code</h3>
                <div class="qr-code-container"><canvas id="qrCodeCanvas" class="qr-code"></canvas></div>
                <div class="share-buttons">
                    <button id="shareQRBtn" class="share-btn"><i class="fas fa-share-alt"></i> Compartilhar</button>
                    <button id="downloadQRBtn" class="share-btn"><i class="fas fa-download"></i> Baixar QR</button>
                </div>
            </div>
            <div id="scanSection" class="hidden" style="margin-top: 20px;">
                <div class="qr-scanner">
                    <video id="qrVideo" playsinline></video>
                    <div class="scan-overlay">
                        <div class="scan-frame"></div>
                        <i class="fas fa-qrcode" style="font-size: 2rem; margin-bottom: 10px;"></i>
                        <p>Posicione o QR Code na área de leitura</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="chatScreen" class="screen">
        <div class="chat-header">
            <button id="backToMainBtn" class="back-button"><i class="fas fa-arrow-left"></i></button>
            <div class="avatar" id="chatAvatar"></div>
            <div id="chatContactName"></div>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="empty-state">
                <i class="fas fa-comment-dots"></i>
                <p>Nenhuma mensagem ainda</p>
                <p>Envie uma mensagem para começar a conversa!</p>
            </div>
        </div>
        <div class="message-input-container">
            <input type="text" id="messageInput" placeholder="Digite sua mensagem...">
            <button id="callButton" class="call-btn" title="Chamada de vídeo"><i class="fas fa-video"></i></button>
            <button id="sendMessageBtn" class="send-btn"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>
    <div id="callScreen" class="call-container">
        <div class="call-video-container">
            <video id="remoteVideo" class="call-video" autoplay playsinline></video>
            <video id="localVideo" class="call-video small" autoplay muted playsinline></video>
        </div>
        <div class="call-info">
            <h2 id="callContactName">Chamando...</h2>
            <div id="callStatus" class="call-status">Conectando...</div>
        </div>
        <div class="call-buttons">
            <button id="acceptCallBtn" class="call-button call-accept hidden" title="Atender"><i class="fas fa-phone"></i></button>
            <button id="rejectCallBtn" class="call-button call-reject hidden" title="Recusar"><i class="fas fa-phone-slash"></i></button>
            <button id="endCallBtn" class="call-button call-end hidden" title="Encerrar"><i class="fas fa-phone-slash"></i></button>
            <button id="muteCallBtn" class="call-button call-mute hidden" title="Mutar"><i class="fas fa-microphone"></i></button>
        </div>
    </div>
    <div class="floating-buttons">
        <button id="showContactsBtn" class="floating-btn" title="Contatos"><i class="fas fa-address-book"></i></button>
        <button id="showQRBtn" class="floating-btn" title="Meu QR Code"><i class="fas fa-qrcode"></i></button>
        <button id="scanQRBtn" class="floating-btn" title="Escanear QR"><i class="fas fa-camera"></i></button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    
    <script>
        // Configuração otimizada do Gun.js
        const gun = Gun({
            peers: ['https://gun-manhattan.herokuapp.com/gun'],
            localStorage: false,
            radisk: false
        });

        // Estado simplificado
        const state = {
            currentUser: null,
            currentContact: null,
            contactsCache: {},
            messagesCache: {},
            db: null,
            peerConnection: null,
            localStream: null,
            remoteStream: null,
            isCaller: false,
            isInCall: false,
            callId: null,
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Cache de elementos DOM
        const el = {
            screens: {},
            buttons: {},
            inputs: {},
            displays: {},
            sections: {}
        };

        // Inicialização otimizada dos elementos
        function initElements() {
            // Mapeamento de screens
            el.screens.userSelect = document.getElementById('userSelectScreen');
            el.screens.newUser = document.getElementById('newUserScreen');
            el.screens.existingUser = document.getElementById('existingUserScreen');
            el.screens.main = document.getElementById('mainScreen');
            el.screens.chat = document.getElementById('chatScreen');
            el.screens.call = document.getElementById('callScreen');
            
            // Mapeamento de buttons
            const buttonIds = [
                'newUserBtn', 'existingUserBtn', 'createUserBtn', 'loadUserBtn', 
                'backToSelectFromNew', 'backToSelectFromExisting', 'showContactsBtn',
                'showQRBtn', 'scanQRBtn', 'backToMainBtn', 'sendMessageBtn', 'copyUserIdBtn',
                'shareQRBtn', 'downloadQRBtn', 'callButton', 'acceptCallBtn', 'rejectCallBtn',
                'endCallBtn', 'muteCallBtn'
            ];
            
            buttonIds.forEach(id => {
                el.buttons[id] = document.getElementById(id);
            });
            
            // Mapeamento de inputs
            el.inputs.newUserName = document.getElementById('newUserName');
            el.inputs.existingUserId = document.getElementById('existingUserId');
            el.inputs.message = document.getElementById('messageInput');
            el.inputs.userIdInput = document.getElementById('userIdInput');
            
            // Mapeamento de displays
            el.displays.contactsList = document.getElementById('contactsList');
            el.displays.qrCode = document.getElementById('qrCodeCanvas');
            el.displays.chatMessages = document.getElementById('chatMessages');
            el.displays.chatAvatar = document.getElementById('chatAvatar');
            el.displays.chatContactName = document.getElementById('chatContactName');
            el.displays.qrVideo = document.getElementById('qrVideo');
            el.displays.userNameDisplay = document.getElementById('userNameDisplay');
            el.displays.userIdDisplayText = document.getElementById('userIdDisplayText');
            el.displays.floatingButtons = document.querySelector('.floating-buttons');
            el.displays.scanOverlay = document.querySelector('.scan-overlay');
            el.displays.createUserFeedback = document.getElementById('createUserFeedback');
            el.displays.loadUserFeedback = document.getElementById('loadUserFeedback');
            el.displays.localVideo = document.getElementById('localVideo');
            el.displays.remoteVideo = document.getElementById('remoteVideo');
            el.displays.callContactName = document.getElementById('callContactName');
            el.displays.callStatus = document.getElementById('callStatus');
            
            // Mapeamento de sections
            el.sections.contacts = document.getElementById('contactsSection');
            el.sections.qr = document.getElementById('qrSection');
            el.sections.scan = document.getElementById('scanSection');
        }

        // Utilitários otimizados
        const utils = {
            escapeHtml: text => text.replace(/</g, '&lt;').replace(/>/g, '&gt;'),
            formatTime: timestamp => new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            
            setButtonLoading: (button, isLoading) => {
                button.disabled = isLoading;
                isLoading ? button.classList.add('btn-loading') : button.classList.remove('btn-loading');
            },
            
            showFeedback: (message, type, context) => {
                const el = document.getElementById(`${context}Feedback`);
                if (el) {
                    el.textContent = message;
                    el.className = `feedback-message feedback-${type}`;
                    el.classList.remove('hidden');
                }
            },
            
            copyToClipboard: text => {
                navigator.clipboard.writeText(text).catch(() => {
                    const input = document.createElement('input');
                    input.value = text;
                    document.body.appendChild(input).select();
                    document.execCommand('copy');
                    document.body.removeChild(input);
                }).then(() => alert('Copiado para a área de transferência!'));
            }
        };

        // Operações do IndexedDB otimizadas
        const db = {
            put: async (storeName, data) => {
                const tx = state.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.put(data);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            get: async (storeName, key) => {
                const tx = state.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            getAll: async (storeName) => {
                const tx = state.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            delete: async (storeName, key) => {
                const tx = state.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.delete(key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                });
            }
        };

        // WebRTC otimizado
        const webrtc = {
            initPeerConnection: () => {
                state.peerConnection = new RTCPeerConnection({ iceServers: state.iceServers });
                
                state.peerConnection.onicecandidate = e => {
                    if (e.candidate) {
                        gun.get('calls').get(state.callId).get('iceCandidates').get(state.currentUser.id).put({
                            candidate: e.candidate,
                            from: state.currentUser.id,
                            to: state.currentContact.id,
                            timestamp: Date.now()
                        });
                    }
                };
                
                state.peerConnection.onconnectionstatechange = () => {
                    const status = state.peerConnection.connectionState;
                    el.displays.callStatus.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    if (status === 'disconnected' || status === 'failed') webrtc.endCall();
                };
                
                state.peerConnection.ontrack = e => {
                    if (e.streams?.[0]) {
                        state.remoteStream = e.streams[0];
                        el.displays.remoteVideo.srcObject = state.remoteStream;
                        el.displays.callStatus.textContent = 'Chamada em andamento';
                    }
                };
                
                if (state.isCaller) {
                    state.peerConnection.createDataChannel('callControl');
                }
            },
            
            startCall: async () => {
                if (!state.currentUser || !state.currentContact || state.isInCall) return;
                
                try {
                    state.callId = Gun.text.random(16);
                    state.isCaller = true;
                    state.isInCall = true;
                    
                    el.displays.callContactName.textContent = state.currentContact.name;
                    el.displays.callStatus.textContent = 'Chamando...';
                    el.screens.call.classList.add('active');
                    
                    webrtc.initPeerConnection();
                    state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    state.localStream.getTracks().forEach(track => state.peerConnection.addTrack(track, state.localStream));
                    el.displays.localVideo.srcObject = state.localStream;
                    
                    const offer = await state.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
                    await state.peerConnection.setLocalDescription(offer);
                    
                    gun.get('calls').get(state.callId).put({
                        from: state.currentUser.id,
                        to: state.currentContact.id,
                        offer: offer,
                        timestamp: Date.now()
                    });
                    
                    const callMessage = {
                        id: Gun.text.random(16),
                        sender: state.currentUser.id,
                        receiver: state.currentContact.id,
                        text: `Você está sendo chamado!`,
                        timestamp: Date.now(),
                        expiresAt: Date.now() + 86400000,
                        callId: state.callId
                    };
                    
                    gun.get('users').get(state.currentContact.id).get('messages').get(callMessage.id).put(callMessage);
                    
                    gun.get('calls').get(state.callId).get('answer').on(answer => {
                        if (answer?.from === state.currentContact.id) {
                            state.peerConnection.setRemoteDescription(new RTCSessionDescription(answer.answer))
                                .catch(e => { console.error('Erro ao configurar resposta:', e); webrtc.endCall(); });
                        }
                    });
                    
                    setTimeout(() => {
                        if (state.isInCall && !state.peerConnection.remoteDescription) {
                            alert('Chamada não atendida');
                            webrtc.endCall();
                        }
                    }, 30000);
                } catch (error) {
                    console.error('Erro na chamada:', error);
                    alert('Erro ao iniciar chamada. Verifique as permissões.');
                    webrtc.endCall();
                }
            },
            
            endCall: () => {
                if (!state.isInCall) return;
                
                if (state.callId) {
                    gun.get('calls').get(state.callId).put(null);
                    gun.get('calls').get(state.callId).get('answer').put(null);
                }
                
                if (state.peerConnection) state.peerConnection.close();
                if (state.localStream) state.localStream.getTracks().forEach(track => track.stop());
                if (state.remoteStream) state.remoteStream.getTracks().forEach(track => track.stop());
                
                state.peerConnection = null;
                state.localStream = null;
                state.remoteStream = null;
                state.isInCall = false;
                state.callId = null;
                
                el.screens.call.classList.remove('active');
            },
            
            joinCall: async (callId) => {
                if (!state.currentUser || state.isInCall) return;
                
                gun.get('calls').get(callId).once(async callData => {
                    if (!callData?.from || callData.to !== state.currentUser.id) {
                        alert('Chamada inválida');
                        return;
                    }
                    
                    const contact = state.contactsCache[callData.from];
                    if (!contact) {
                        alert('Contato não encontrado');
                        return;
                    }
                    
                    state.callId = callId;
                    state.currentContact = contact;
                    state.isCaller = false;
                    state.isInCall = true;
                    
                    el.displays.callContactName.textContent = contact.name;
                    el.displays.callStatus.textContent = 'Chamada recebida';
                    el.screens.call.classList.add('active');
                    
                    try {
                        webrtc.initPeerConnection();
                        state.localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                        state.localStream.getTracks().forEach(track => state.peerConnection.addTrack(track, state.localStream));
                        el.displays.localVideo.srcObject = state.localStream;
                        
                        await state.peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
                        const answer = await state.peerConnection.createAnswer();
                        await state.peerConnection.setLocalDescription(answer);
                        
                        gun.get('calls').get(callId).get('answer').put({
                            from: state.currentUser.id,
                            to: callData.from,
                            answer: answer,
                            timestamp: Date.now()
                        });
                    } catch (error) {
                        console.error('Erro ao entrar na chamada:', error);
                        alert('Erro ao atender chamada.');
                        webrtc.endCall();
                    }
                });
            }
        };

        // Aplicação principal otimizada
        const app = {
            init: async () => {
                initElements();
                try {
                    state.db = await new Promise((resolve, reject) => {
                        const req = indexedDB.open('BunnyChatDB', 3);
                        req.onerror = () => reject(req.error);
                        req.onsuccess = () => resolve(req.result);
                        req.onupgradeneeded = e => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('users')) db.createObjectStore('users', { keyPath: 'id' });
                            if (!db.objectStoreNames.contains('contacts')) db.createObjectStore('contacts', { keyPath: 'id' });
                            if (!db.objectStoreNames.contains('messages')) {
                                const store = db.createObjectStore('messages', { keyPath: 'id' });
                                store.createIndex('conversation', ['sender', 'receiver'], { unique: false });
                            }
                        };
                    });
                    
                    await app.checkForExistingUser();
                    app.setupEventListeners();
                    setInterval(app.cleanupExpiredMessages, 3600000);
                } catch (error) {
                    console.error('Erro na inicialização:', error);
                    alert('Erro ao iniciar. Recarregue a página.');
                }
            },
            
            setupEventListeners: () => {
                // Navegação
                el.buttons.newUser.addEventListener('click', () => app.showScreen('newUser'));
                el.buttons.existingUser.addEventListener('click', () => app.showScreen('existingUser'));
                el.buttons.backToSelectFromNew.addEventListener('click', () => app.showScreen('userSelect'));
                el.buttons.backToSelectFromExisting.addEventListener('click', () => app.showScreen('userSelect'));
                el.buttons.backToMain.addEventListener('click', () => { app.stopQrScanner(); app.showScreen('main'); });
                
                // Usuário
                el.buttons.createUser.addEventListener('click', app.createUser);
                el.buttons.loadUser.addEventListener('click', app.loadUser);
                
                // Ações principais
                el.buttons.showContacts.addEventListener('click', () => app.toggleSection('contacts'));
                el.buttons.showQR.addEventListener('click', () => { app.toggleSection('qr'); app.showUserQRInfo(); app.generateQrCode(); });
                el.buttons.scanQR.addEventListener('click', () => app.toggleSection('scan'));
                
                // Chat
                el.buttons.sendMessage.addEventListener('click', app.sendMessage);
                el.inputs.message.addEventListener('keypress', e => e.key === 'Enter' && app.sendMessage());
                
                // Chamadas
                el.buttons.callButton.addEventListener('click', () => state.currentContact && webrtc.startCall());
                el.buttons.acceptCallBtn.addEventListener('click', () => {
                    el.buttons.acceptCallBtn.classList.add('hidden');
                    el.buttons.rejectCallBtn.classList.add('hidden');
                    el.buttons.endCallBtn.classList.remove('hidden');
                    el.buttons.muteCallBtn.classList.remove('hidden');
                    el.displays.callStatus.textContent = 'Chamada em andamento';
                });
                el.buttons.rejectCallBtn.addEventListener('click', webrtc.endCall);
                el.buttons.endCallBtn.addEventListener('click', webrtc.endCall);
                el.buttons.muteCallBtn.addEventListener('click', () => {
                    if (!state.localStream) return;
                    state.isMuted = !state.isMuted;
                    state.localStream.getAudioTracks().forEach(track => track.enabled = !state.isMuted);
                    el.buttons.muteCallBtn.innerHTML = state.isMuted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
                });
                
                // Utilitários
                el.buttons.copyUserId.addEventListener('click', () => utils.copyToClipboard(state.currentUser?.id || ''));
                el.buttons.shareQR.addEventListener('click', app.shareQRCode);
                el.buttons.downloadQR.addEventListener('click', app.downloadQRCode);
                
                // Event delegation
                el.displays.contactsList.addEventListener('click', e => {
                    const contactId = e.target.closest('.contact-item')?.getAttribute('data-contact-id');
                    const deleteBtn = e.target.closest('.delete-contact-btn');
                    const callBtn = e.target.closest('.call-contact-btn');
                    
                    if (deleteBtn) {
                        e.stopPropagation();
                        app.removeContact(deleteBtn.getAttribute('data-contact-id'));
                    } else if (callBtn) {
                        e.stopPropagation();
                        const contact = state.contactsCache[callBtn.getAttribute('data-contact-id')];
                        if (contact) {
                            state.currentContact = contact;
                            webrtc.startCall();
                        }
                    } else if (contactId && state.contactsCache[contactId]) {
                        state.currentContact = state.contactsCache[contactId];
                        app.showChatScreen();
                    }
                });
                
                el.displays.chatMessages.addEventListener('click', e => {
                    const callBtn = e.target.closest('.join-call-btn');
                    if (callBtn) {
                        e.stopPropagation();
                        webrtc.joinCall(callBtn.getAttribute('data-call-id'));
                    }
                });
            },
            
            checkForExistingUser: async () => {
                try {
                    const users = await db.getAll('users');
                    if (users.length) {
                        state.currentUser = users[0];
                        await app.loadLocalData();
                        app.showScreen('main');
                    } else {
                        app.showScreen('userSelect');
                    }
                } catch (error) {
                    console.error('Erro ao verificar usuário:', error);
                    app.showScreen('userSelect');
                }
            },
            
            loadLocalData: async () => {
                try {
                    const contacts = await db.getAll('contacts');
                    state.contactsCache = contacts.reduce((acc, contact) => (acc[contact.id] = contact, acc), {});
                    app.renderContacts(Object.values(state.contactsCache));
                } catch (error) {
                    console.error('Erro ao carregar dados:', error);
                }
            },
            
            showScreen: (screenName) => {
                Object.values(el.screens).forEach(screen => screen.classList.remove('active'));
                el.screens[screenName].classList.add('active');
                el.displays.floatingButtons.classList.toggle('visible', screenName === 'main' || screenName === 'chat');
                if (screenName === 'main') el.sections.contacts.style.display = 'block';
            },
            
            toggleSection: (sectionName) => {
                Object.values(el.sections).forEach(section => section.classList.add('hidden'));
                el.sections[sectionName].classList.remove('hidden');
                sectionName === 'scan' ? app.startQrScanner() : app.stopQrScanner();
            },
            
            createUser: async () => {
                const userName = el.inputs.newUserName.value.trim();
                if (!userName) return utils.showFeedback('Digite um nome', 'error', 'createUser');
                
                utils.setButtonLoading(el.buttons.createUser, true);
                
                try {
                    const user = { 
                        id: Gun.text.random(16), 
                        name: userName, 
                        createdAt: Date.now(),
                        lastSeen: Date.now()
                    };
                    
                    await db.put('users', user);
                    gun.get('users').get(user.id).put(user);
                    
                    state.currentUser = user;
                    state.contactsCache = {};
                    utils.showFeedback('Usuário criado!', 'success', 'createUser');
                    
                    setTimeout(() => {
                        utils.hideFeedback('createUser');
                        app.showScreen('main');
                        app.showUserQRInfo();
                        app.generateQrCode();
                    }, 800);
                } catch (error) {
                    console.error('Erro ao criar usuário:', error);
                    utils.showFeedback('Erro ao criar usuário', 'error', 'createUser');
                } finally {
                    utils.setButtonLoading(el.buttons.createUser, false);
                }
            },
            
            loadUser: async () => {
                const userId = el.inputs.existingUserId.value.trim();
                if (!userId) return utils.showFeedback('Digite um ID', 'error', 'loadUser');
                
                utils.setButtonLoading(el.buttons.loadUser, true);
                
                try {
                    let user = await db.get('users', userId) || 
                              await new Promise(resolve => gun.get('users').get(userId).once(resolve, { wait: 2000 }));
                    
                    if (user?.name) {
                        await db.put('users', user);
                        state.currentUser = user;
                        await app.loadLocalData();
                        utils.showFeedback('Usuário carregado!', 'success', 'loadUser');
                        setTimeout(() => app.showScreen('main'), 1000);
                    } else {
                        utils.showFeedback('Usuário não encontrado', 'error', 'loadUser');
                    }
                } catch (error) {
                    console.error('Erro ao carregar usuário:', error);
                    utils.showFeedback('Erro ao carregar usuário', 'error', 'loadUser');
                } finally {
                    utils.setButtonLoading(el.buttons.loadUser, false);
                }
            },
            
            showUserQRInfo: () => {
                if (!state.currentUser) return;
                el.displays.userNameDisplay.textContent = state.currentUser.name;
                el.displays.userIdDisplayText.textContent = state.currentUser.id;
            },
            
            generateQrCode: () => {
                if (!state.currentUser) return;
                
                const qrData = JSON.stringify({
                    app: "BunnyChat",
                    version: 1,
                    userId: state.currentUser.id,
                    userName: state.currentUser.name
                });
                
                QRCode.toCanvas(el.displays.qrCode, qrData, {
                    width: 200,
                    margin: 2,
                    color: { dark: '#5A2A3E', light: '#FFF2F5' }
                }, error => error && console.error('Erro no QR Code:', error));
            },
            
            shareQRCode: () => {
                navigator.share ? navigator.share({
                    title: 'Meu BunnyChat QR Code',
                    text: `Adicione-me no BunnyChat! Meu nome: ${state.currentUser.name}`,
                    url: `${window.location.href}?user=${state.currentUser.id}`
                }).catch(() => utils.copyToClipboard(state.currentUser.id)) : utils.copyToClipboard(state.currentUser.id);
            },
            
            downloadQRCode: () => {
                const link = document.createElement('a');
                link.download = `BunnyChat-${state.currentUser.name}.png`;
                link.href = el.displays.qrCode.toDataURL();
                link.click();
            },
            
            renderContacts: (contacts) => {
                el.displays.contactsList.innerHTML = contacts
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map(contact => `
                        <div class="contact-item" data-contact-id="${contact.id}">
                            <div class="avatar">${contact.name.charAt(0).toUpperCase()}</div>
                            <div style="flex: 1;">
                                <div style="font-weight: bold;">${contact.name}</div>
                                <div style="font-size: 0.8rem; opacity: 0.7;">${contact.id}</div>
                            </div>
                            <button class="call-contact-btn" title="Chamar" data-contact-id="${contact.id}">
                                <i class="fas fa-video"></i>
                            </button>
                            <button class="delete-contact-btn" title="Excluir contato" data-contact-id="${contact.id}">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `).join('');
            },
            
            removeContact: async (userId) => {
                if (!state.currentUser || !userId || userId === state.currentUser.id) return;
                
                const contact = state.contactsCache[userId];
                if (!contact || !confirm(`Remover ${contact.name} dos contatos?`)) return;
                
                try {
                    await db.delete('contacts', userId);
                    delete state.contactsCache[userId];
                    gun.get('users').get(state.currentUser.id).get('contacts').get(userId).put(null);
                    app.renderContacts(Object.values(state.contactsCache));
                    
                    if (state.currentContact?.id === userId) {
                        state.currentContact = null;
                        app.showScreen('main');
                    }
                } catch (error) {
                    console.error('Erro ao remover contato:', error);
                    alert('Erro ao remover contato.');
                }
            },
            
            showChatScreen: () => {
                if (!state.currentContact) return;
                
                el.displays.chatAvatar.textContent = state.currentContact.name.charAt(0).toUpperCase();
                el.displays.chatContactName.textContent = state.currentContact.name;
                app.showScreen('chat');
                app.syncMessages();
            },
            
            syncMessages: async () => {
                if (!state.currentUser || !state.currentContact) return;
                
                try {
                    const contactId = state.currentContact.id;
                    const messages = await db.getMessages(state.currentUser.id, contactId);
                    const validMessages = messages.filter(msg => msg.expiresAt > Date.now());
                    
                    state.messagesCache[contactId] = validMessages;
                    app.renderMessages(validMessages);
                    
                    gun.get('users').get(state.currentUser.id).get('messages').map().on(msg => {
                        if (!msg || msg.expiresAt < Date.now()) return;
                        
                        const isRelevant = (msg.sender === contactId && msg.receiver === state.currentUser.id) || 
                                         (msg.sender === state.currentUser.id && msg.receiver === contactId);
                        
                        if (isRelevant && !state.messagesCache[contactId]?.some(m => m.id === msg.id)) {
                            db.put('messages', msg);
                            state.messagesCache[contactId] = [...(state.messagesCache[contactId] || []), msg];
                            app.renderMessages([msg]);
                        }
                    });
                } catch (error) {
                    console.error('Erro ao sincronizar mensagens:', error);
                }
            },
            
            renderMessages: (messages) => {
                if (!messages.length && !el.displays.chatMessages.querySelector('.message-item')) {
                    el.displays.chatMessages.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-comment-dots"></i>
                            <p>Nenhuma mensagem ainda</p>
                            <p>Envie uma mensagem para começar a conversa!</p>
                        </div>
                    `;
                    return;
                }
                
                if (messages.length && el.displays.chatMessages.querySelector('.empty-state')) {
                    el.displays.chatMessages.innerHTML = '';
                }
                
                messages.forEach(msg => {
                    if (document.getElementById(`msg-${msg.id}`)) return;
                    
                    const isSender = msg.sender === state.currentUser.id;
                    const expiryDate = new Date(msg.expiresAt);
                    
                    const messageElement = document.createElement('div');
                    messageElement.id = `msg-${msg.id}`;
                    messageElement.className = 'message-item';
                    messageElement.style.alignItems = isSender ? 'flex-end' : 'flex-start';
                    messageElement.style.backgroundColor = isSender ? 'var(--secondary)' : 'white';
                    
                    messageElement.innerHTML = `
                        <div class="message-header">
                            ${!isSender ? `<div class="avatar message-avatar">${state.currentContact.name.charAt(0).toUpperCase()}</div>` : ''}
                            <div class="message-sender">${isSender ? 'Você' : state.currentContact.name}</div>
                            <div class="message-time">${utils.formatTime(msg.timestamp)}</div>
                        </div>
                        <div class="message-content">${utils.escapeHtml(msg.text)}</div>
                        ${msg.callId ? `
                            <div class="call-button-container">
                                <button class="call-button join-call-btn" data-call-id="${msg.callId}">
                                    <i class="fas fa-video"></i> Entrar na Chamada
                                </button>
                            </div>
                        ` : ''}
                        ${!isSender ? `<div class="message-expiry">Expira: ${expiryDate.toLocaleDateString()} às ${expiryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>` : ''}
                    `;
                    
                    el.displays.chatMessages.appendChild(messageElement);
                    el.displays.chatMessages.scrollTop = el.displays.chatMessages.scrollHeight;
                });
            },
            
            sendMessage: async () => {
                const messageText = el.inputs.message.value.trim();
                if (!messageText || !state.currentUser || !state.currentContact) return;
                
                const message = {
                    id: Gun.text.random(16),
                    sender: state.currentUser.id,
                    receiver: state.currentContact.id,
                    text: messageText,
                    timestamp: Date.now(),
                    expiresAt: Date.now() + 86400000
                };
                
                try {
                    await db.put('messages', message);
                    gun.get('users').get(state.currentUser.id).get('messages').get(message.id).put(message);
                    gun.get('users').get(state.currentContact.id).get('messages').get(message.id).put(message);
                    
                    if (!state.messagesCache[state.currentContact.id]) {
                        state.messagesCache[state.currentContact.id] = [];
                    }
                    state.messagesCache[state.currentContact.id].push(message);
                    
                    app.renderMessages([message]);
                    el.inputs.message.value = '';
                } catch (error) {
                    console.error('Erro ao enviar mensagem:', error);
                    alert('Erro ao enviar mensagem.');
                }
            },
            
            cleanupExpiredMessages: async () => {
                if (!state.currentUser) return;
                
                try {
                    const now = Date.now();
                    const messages = await db.getAll('messages');
                    const expired = messages.filter(msg => msg.expiresAt < now);
                    
                    for (const msg of expired) {
                        await db.delete('messages', msg.id);
                        gun.get('users').get(state.currentUser.id).get('messages').get(msg.id).put(null);
                    }
                    
                    Object.keys(state.messagesCache).forEach(contactId => {
                        state.messagesCache[contactId] = state.messagesCache[contactId].filter(msg => msg.expiresAt > now);
                    });
                } catch (error) {
                    console.error('Erro ao limpar mensagens:', error);
                }
            },
            
            startQrScanner: () => {
                if (state.qrScannerActive) return;
                state.qrScannerActive = true;
                
                if (el.displays.qrVideo.srcObject) {
                    el.displays.qrVideo.srcObject.getTracks().forEach(track => track.stop());
                }

                el.displays.scanOverlay.style.display = 'none';

                navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                }).then(stream => {
                    el.displays.qrVideo.srcObject = stream;
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    
                    function scanFrame() {
                        if (!state.qrScannerActive) return;

                        try {
                            if (el.displays.qrVideo.readyState === el.displays.qrVideo.HAVE_ENOUGH_DATA) {
                                canvas.width = el.displays.qrVideo.videoWidth;
                                canvas.height = el.displays.qrVideo.videoHeight;
                                ctx.drawImage(el.displays.qrVideo, 0, 0, canvas.width, canvas.height);
                                
                                const code = jsQR(ctx.getImageData(0, 0, canvas.width, canvas.height).data, canvas.width, canvas.height, {
                                    inversionAttempts: "dontInvert",
                                });

                                if (code) {
                                    try {
                                        const qrData = JSON.parse(code.data);
                                        if (qrData.app === "BunnyChat" && qrData.userId && qrData.userId !== state.currentUser.id) {
                                            app.stopQrScanner();
                                            app.addContact(qrData.userId, qrData.userName || 'Novo Contato');
                                            return;
                                        }
                                    } catch (e) {
                                        console.log('QR inválido:', e);
                                    }
                                }
                            }
                            requestAnimationFrame(scanFrame);
                        } catch (e) {
                            console.error('Erro no scanner:', e);
                        }
                    }

                    el.displays.qrVideo.onplaying = () => {
                        el.displays.scanOverlay.style.display = 'flex';
                        scanFrame();
                    };
                }).catch(err => {
                    console.error('Erro na câmera:', err);
                    alert('Não foi possível acessar a câmera.');
                    app.stopQrScanner();
                });
            },
            
            stopQrScanner: () => {
                if (!state.qrScannerActive) return;
                state.qrScannerActive = false;
                el.displays.scanOverlay.style.display = 'flex';
                
                if (el.displays.qrVideo.srcObject) {
                    el.displays.qrVideo.srcObject.getTracks().forEach(track => track.stop());
                    el.displays.qrVideo.srcObject = null;
                }
            },
            
            addContact: async (userId, userName) => {
                if (!state.currentUser || !userId || state.contactsCache[userId]) {
                    alert(state.contactsCache[userId] ? 'Contato já existe!' : 'Erro ao adicionar contato');
                    return;
                }

                const contact = { id: userId, name: userName, timestamp: Date.now() };
                const myContact = { id: state.currentUser.id, name: state.currentUser.name, timestamp: Date.now() };
                
                try {
                    await db.put('contacts', contact);
                    state.contactsCache[userId] = contact;
                    app.renderContacts(Object.values(state.contactsCache));
                    gun.get('users').get(state.currentUser.id).get('contacts').get(userId).put(contact);
                    
                    const otherUserExists = await new Promise(resolve => {
                        gun.get('users').get(userId).once(user => resolve(!!user), { wait: 2000 });
                    });

                    if (otherUserExists) {
                        gun.get('users').get(userId).get('contacts').get(state.currentUser.id).put(myContact);
                    }
                    
                    alert(`Contato ${userName} adicionado!`);
                } catch (error) {
                    console.error('Erro ao adicionar contato:', error);
                    alert('Erro ao adicionar contato.');
                }
            }
        };

        // Inicializa o aplicativo
        window.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>
</html>
